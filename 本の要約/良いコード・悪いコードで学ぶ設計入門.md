# 良いコード・悪いコードで学ぶ設計入門

## 第1章 悪しき構造の弊害を知覚する

### 1.1 意味不明な命名

* ``method01``や``method1``といった連番で名前をつけるとわかりにくくなる。

### 1.2 理解を困難にする条件分岐のネスト

* ネストが深くなればなるほど可読性が低くなっていく。

### 1.3 さまざまな悪魔を招きやすいデータクラス

* データを格納するためだけのクラスもよくない。

#### 1.3.1 仕様変更時に牙をむく悪魔

#### 1.3.2 重複コード

* 『税込み計算ロジック』がいたるところにべた書きで記述されているといった場合、税率が変更されるとその部分すべて修正しなおさないといけないため変更に弱い設計となる。

#### 1.3.3 修正漏れ

* 重複コードがどこにどのぐらいあるか把握していないと修正漏れが発生しやすい。

#### 1.3.4 可読性低下

#### 1.3.5 未初期化状態(生焼けオブジェクト)

* いわゆるヌルポが発生しやすいコード。特にインスタンス化やフィールド(メンバ変数)で起きやすい?

### 1.4 悪魔退治の基本

* 彼を知り己を知れば百戦殆からず。

## 第2章 設計の初歩

### 2.1 省略せずに意図が伝わる名前を設計する

* ``int d1; // ダメージ量``といった名前ではなく、``int damageAmount; // ダメージ量``のように名前から意図が推測出来るようなものを選択するべき。

### 2.2 変数を使いまわさない、目的ごとの変数を用意する

* 横着せずに目的ごとに変数を用意すべき。

### 2.3 べた書きせず、意味のあるまとまりでメソッド化

* 処理のまとまりごとに関数化(メソッド化)すべき。

### 2.4 関係しあうデータとロジックをクラスにまとめる

* オブジェクト指向的発想。

## 第3章 クラス設計 －すべてにつながる設計の基盤－

### 3.1 クラス単体で正常に動作するよう設計する

#### 3.1.1 悪魔に負けない、強固なクラスの構成要素

* クラスは必ず**インスタンス変数(メンバ変数)とメソッドがそれぞれ一つ以上あること**。

#### 3.1.2 すべてのクラスに備わる自己防衛責務

* オブジェクトには**自己防衛責務**を課す。つまり、他オブジェクトからデータを勝手に変更されないようにする。

### 3.2 成熟したクラスへ成長させる設計術

#### 3.2.1 コンストラクタで確実に正常値を設定する

* コンストラクタでメンバ変数の初期化を行う。「ファイルが存在しない」といった例外についてはコンストラクタから例外を投げるなりして通知する。

#### 3.2.2 計算ロジックをデータ保持側に寄せるという

* できる限りデータクラス(データを格納するだけのクラス)を作らずに、そのオブジェクト自身が処理するように設計する。Moneyクラスにaddメソッドを追加して「お金自身が計算する」といった感じで。

#### 3.2.3 不変で思わぬ動作を防ぐ

* C++でいえばconst, Javaでいえばfinalを付けてメンバ変数が変更されるのを防ぐ。

#### 3.2.4 変更したい場合は新しいインスタンスを作成する

* 「テスト駆動開発」(Kent Beck氏著)でいう、**Value Objectパターン**を適用してオブジェクトが持つデータが書き換わるのを防ぐ。

#### 3.2.5 メソッド引数やローカル変数にもfinalを付け不変にする

* これもC++でいえば``void func1( const std::string& text );``の 引数のconstのこと。

#### 3.2.6 「値の渡し間違い」を型で防止する

* たとえば金額を渡すと追加するメンバ関数があるとすると、そのメンバ関数には不正な金額(指定範囲外の値 等)が渡される可能性がある。そういう場合は新たにMoneyといったクラスを用意してそれを渡すようにする。

#### 3.2.7 現実の営みにはないメソッドを追加しないこと

* 要らない処理(メソッド)は追加しない。

### 3.3 悪魔退治の効果を検証する

* 『クラス設計とは、インスタンス変数を不正状態に陥らせないためのしくみづくりと言っても過言ではありません』(当書 p.35)

### 3.4 プログラム構造の問題解決に役立つ設計パターン

#### 3.4.1 完全コンストラクタ

* **完全コンストラクタパターン**: 引数無しのコンストラクタで初期化しておいて後から設定しなおすパターン。

#### 3.4.2. 値オブジェクト

* **値オブジェクトパターン**: つまり**Value Objectパターン**のこと。



