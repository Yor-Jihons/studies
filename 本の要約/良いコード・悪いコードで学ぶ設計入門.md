# 良いコード・悪いコードで学ぶ設計入門

## 第1章 悪しき構造の弊害を知覚する

### 1.1 意味不明な命名

* ``method01``や``method1``といった連番で名前をつけるとわかりにくくなる。

### 1.2 理解を困難にする条件分岐のネスト

* ネストが深くなればなるほど可読性が低くなっていく。

### 1.3 さまざまな悪魔を招きやすいデータクラス

* データを格納するためだけのクラスもよくない。

#### 1.3.1 仕様変更時に牙をむく悪魔

#### 1.3.2 重複コード

* 『税込み計算ロジック』がいたるところにべた書きで記述されているといった場合、税率が変更されるとその部分すべて修正しなおさないといけないため変更に弱い設計となる。

#### 1.3.3 修正漏れ

* 重複コードがどこにどのぐらいあるか把握していないと修正漏れが発生しやすい。

#### 1.3.4 可読性低下

#### 1.3.5 未初期化状態(生焼けオブジェクト)

* いわゆるヌルポが発生しやすいコード。特にインスタンス化やフィールド(メンバ変数)で起きやすい?

### 1.4 悪魔退治の基本

* 彼を知り己を知れば百戦殆からず。

## 第2章 設計の初歩

### 2.1 省略せずに意図が伝わる名前を設計する

* ``int d1; // ダメージ量``といった名前ではなく、``int damageAmount; // ダメージ量``のように名前から意図が推測出来るようなものを選択するべき。

### 2.2 変数を使いまわさない、目的ごとの変数を用意する

* 横着せずに目的ごとに変数を用意すべき。

### 2.3 べた書きせず、意味のあるまとまりでメソッド化

* 処理のまとまりごとに関数化(メソッド化)すべき。

### 2.4 関係しあうデータとロジックをクラスにまとめる

* オブジェクト指向的発想。

## 第3章 クラス設計 －すべてにつながる設計の基盤－

### 3.1 クラス単体で正常に動作するよう設計する

#### 3.1.1 悪魔に負けない、強固なクラスの構成要素

* クラスは必ず**インスタンス変数(メンバ変数)とメソッドがそれぞれ一つ以上あること**。

#### 3.1.2 すべてのクラスに備わる自己防衛責務

* オブジェクトには**自己防衛責務**を課す。つまり、他オブジェクトからデータを勝手に変更されないようにする。

### 3.2 成熟したクラスへ成長させる設計術

#### 3.2.1 コンストラクタで確実に正常値を設定する

* コンストラクタでメンバ変数の初期化を行う。「ファイルが存在しない」といった例外についてはコンストラクタから例外を投げるなりして通知する。

#### 3.2.2 計算ロジックをデータ保持側に寄せるという

* できる限りデータクラス(データを格納するだけのクラス)を作らずに、そのオブジェクト自身が処理するように設計する。Moneyクラスにaddメソッドを追加して「お金自身が計算する」といった感じで。

#### 3.2.3 不変で思わぬ動作を防ぐ

* C++でいえばconst, Javaでいえばfinalを付けてメンバ変数が変更されるのを防ぐ。

#### 3.2.4 変更したい場合は新しいインスタンスを作成する

* 「テスト駆動開発」(Kent Beck氏著)でいう、**Value Objectパターン**を適用してオブジェクトが持つデータが書き換わるのを防ぐ。

#### 3.2.5 メソッド引数やローカル変数にもfinalを付け不変にする

* これもC++でいえば``void func1( const std::string& text );``の 引数のconstのこと。

#### 3.2.6 「値の渡し間違い」を型で防止する

* たとえば金額を渡すと追加するメンバ関数があるとすると、そのメンバ関数には不正な金額(指定範囲外の値 等)が渡される可能性がある。そういう場合は新たにMoneyといったクラスを用意してそれを渡すようにする。

#### 3.2.7 現実の営みにはないメソッドを追加しないこと

* 要らない処理(メソッド)は追加しない。

### 3.3 悪魔退治の効果を検証する

* 『クラス設計とは、インスタンス変数を不正状態に陥らせないためのしくみづくりと言っても過言ではありません』(当書 p.35)

### 3.4 プログラム構造の問題解決に役立つ設計パターン

#### 3.4.1 完全コンストラクタ

* **完全コンストラクタパターン**: 引数無しのコンストラクタで初期化しておいて後から設定しなおすパターン。

#### 3.4.2. 値オブジェクト

* **値オブジェクトパターン**: つまり**Value Objectパターン**のこと。

## 第4章 不変の活用 －安定動作を構築する－

* 変数の値を変更するなどの状態変更できることを**可変(ミュータブル)**といい、逆に状態変更ができないことを**不変(イミュータブル)**という。

### 4.1 再代入

* 変数に再度値を代入することを**再代入**、または**破壊的代入**という。
* 以下のコードのように変数tmpを使いまわすと意図がはっきりしない。**それぞれ別の変数として宣言すべき**。

```Java
int damage(){
    // 腕力と武器性能が基本攻撃力
    int tmp = member.power() + member.weaponAttack();
    // スピードで攻撃力を補正
    tmp = (int)(tmp * (1f + member.seed() / 100f));
    // 攻撃力から敵の防御力を差し引いたのがダメージ
    tmp = tmp - (int)(enemy.defence() / 2);
    // ダメージ値が負数にならないよう補正
    tmp = Math.max( 0, tmp );
return tmp;
}
```

#### 4.1.1 不変にして再代入を防ぐ

* C++等で言えばconst, Javaでいえばfinalで定数化して再代入を防ぐ。

#### 4.1.2 引数も不変にする

* 引数に対しても行う。

### 4.2 可変がもたらす意図せぬ影響

#### 4.2.1 ケース1 可変インスタンスの使い回し

* GUIで言えば「スタイル用クラスオブジェクトを引数として渡してコントロールのデザインを動的に変更する」といった場面の場合、control1, control2 はそれぞれ別の style1, style2 といった感じで渡すオブジェクトも新しく作る。そうするとstyle1が変更されてもstyle2は変更していないため副作用が小さく済む。

#### 4.2.2 ケース2 関数による可変インスタンスの操作

* オブジェクトが持つデータも注意が必要。マルチスレッドのような場面でスレッド1が想定しないメソッドの呼び出しでデータが破壊される可能性があるため。

#### 4.2.3 副作用のデメリット

* 想定したデータの変更以外の変更に注意せよ。

#### 4.2.4 関数の影響範囲を限定する

* 以下に従って設計すること。
  * データ、つまり状態を引数で受け取る。
  * 状態は変更しない。
  * 値は関数の戻り値として返す。

#### 4.2.5 不変にして予期せぬ動作を防ぐ

> 仕様変更時に意図せず副作用のある関数が作りこまれてしまい、予期しない動作を招いてしまう、ということがよくあります。(当書 p.50)

### 4.3 不変と可変の取り扱い方針

#### 4.3.1 デフォルトは不変に

* 通常は不変で行う。

#### 4.3.2 どんなときに可変にしてよいか

* 「大量のデータを高速に処理する場合」や「リソース制約の強い環境」、「画像処理」といった**パフォーマンスに影響が出る場合は可変**にしてよい。
* もしくはループ処理内といったスコープが小さい場合も可変を認める。

#### 4.3.3 正しく状態変更するメソッドを設計する

* データの管理は基本的にオブジェクトに行わせるべき。

#### 4.3.4 コード外とのやりとりは局所化する

* ファイルの読み書きやDB操作といった外部とやりとりする場合は注意が必要。


