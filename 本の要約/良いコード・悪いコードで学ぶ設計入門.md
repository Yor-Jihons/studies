# 良いコード・悪いコードで学ぶ設計入門

## 第1章 悪しき構造の弊害を知覚する

### 1.1 意味不明な命名

* ``method01``や``method1``といった連番で名前をつけるとわかりにくくなる。

### 1.2 理解を困難にする条件分岐のネスト

* ネストが深くなればなるほど可読性が低くなっていく。

### 1.3 さまざまな悪魔を招きやすいデータクラス

* データを格納するためだけのクラスもよくない。

#### 1.3.1 仕様変更時に牙をむく悪魔

#### 1.3.2 重複コード

* 『税込み計算ロジック』がいたるところにべた書きで記述されているといった場合、税率が変更されるとその部分すべて修正しなおさないといけないため変更に弱い設計となる。

#### 1.3.3 修正漏れ

* 重複コードがどこにどのぐらいあるか把握していないと修正漏れが発生しやすい。

#### 1.3.4 可読性低下

#### 1.3.5 未初期化状態(生焼けオブジェクト)

* いわゆるヌルポが発生しやすいコード。特にインスタンス化やフィールド(メンバ変数)で起きやすい?

### 1.4 悪魔退治の基本

* 彼を知り己を知れば百戦殆からず。

## 第2章 設計の初歩

### 2.1 省略せずに意図が伝わる名前を設計する

* ``int d1; // ダメージ量``といった名前ではなく、``int damageAmount; // ダメージ量``のように名前から意図が推測出来るようなものを選択するべき。

### 2.2 変数を使いまわさない、目的ごとの変数を用意する

* 横着せずに目的ごとに変数を用意すべき。

### 2.3 べた書きせず、意味のあるまとまりでメソッド化

* 処理のまとまりごとに関数化(メソッド化)すべき。

### 2.4 関係しあうデータとロジックをクラスにまとめる

* オブジェクト指向的発想。

## 第3章 クラス設計 －すべてにつながる設計の基盤－

### 3.1 クラス単体で正常に動作するよう設計する

#### 3.1.1 悪魔に負けない、強固なクラスの構成要素

* クラスは必ず**インスタンス変数(メンバ変数)とメソッドがそれぞれ一つ以上あること**。

#### 3.1.2 すべてのクラスに備わる自己防衛責務

* オブジェクトには**自己防衛責務**を課す。つまり、他オブジェクトからデータを勝手に変更されないようにする。

### 3.2 成熟したクラスへ成長させる設計術

#### 3.2.1 コンストラクタで確実に正常値を設定する

* コンストラクタでメンバ変数の初期化を行う。「ファイルが存在しない」といった例外についてはコンストラクタから例外を投げるなりして通知する。

#### 3.2.2 計算ロジックをデータ保持側に寄せるという

* できる限りデータクラス(データを格納するだけのクラス)を作らずに、そのオブジェクト自身が処理するように設計する。Moneyクラスにaddメソッドを追加して「お金自身が計算する」といった感じで。

#### 3.2.3 不変で思わぬ動作を防ぐ

* C++でいえばconst, Javaでいえばfinalを付けてメンバ変数が変更されるのを防ぐ。

#### 3.2.4 変更したい場合は新しいインスタンスを作成する

* 「テスト駆動開発」(Kent Beck氏著)でいう、**Value Objectパターン**を適用してオブジェクトが持つデータが書き換わるのを防ぐ。

#### 3.2.5 メソッド引数やローカル変数にもfinalを付け不変にする

* これもC++でいえば``void func1( const std::string& text );``の 引数のconstのこと。

#### 3.2.6 「値の渡し間違い」を型で防止する

* たとえば金額を渡すと追加するメンバ関数があるとすると、そのメンバ関数には不正な金額(指定範囲外の値 等)が渡される可能性がある。そういう場合は新たにMoneyといったクラスを用意してそれを渡すようにする。

#### 3.2.7 現実の営みにはないメソッドを追加しないこと

* 要らない処理(メソッド)は追加しない。

### 3.3 悪魔退治の効果を検証する

* 『クラス設計とは、インスタンス変数を不正状態に陥らせないためのしくみづくりと言っても過言ではありません』(当書 p.35)

### 3.4 プログラム構造の問題解決に役立つ設計パターン

#### 3.4.1 完全コンストラクタ

* **完全コンストラクタパターン**: 引数無しのコンストラクタで初期化しておいて後から設定しなおすパターン。

#### 3.4.2. 値オブジェクト

* **値オブジェクトパターン**: つまり**Value Objectパターン**のこと。

## 第4章 不変の活用 －安定動作を構築する－

* 変数の値を変更するなどの状態変更できることを**可変(ミュータブル)**といい、逆に状態変更ができないことを**不変(イミュータブル)**という。

### 4.1 再代入

* 変数に再度値を代入することを**再代入**、または**破壊的代入**という。
* 以下のコードのように変数tmpを使いまわすと意図がはっきりしない。**それぞれ別の変数として宣言すべき**。

```Java
int damage(){
    // 腕力と武器性能が基本攻撃力
    int tmp = member.power() + member.weaponAttack();
    // スピードで攻撃力を補正
    tmp = (int)(tmp * (1f + member.seed() / 100f));
    // 攻撃力から敵の防御力を差し引いたのがダメージ
    tmp = tmp - (int)(enemy.defence() / 2);
    // ダメージ値が負数にならないよう補正
    tmp = Math.max( 0, tmp );
return tmp;
}
```

#### 4.1.1 不変にして再代入を防ぐ

* C++等で言えばconst, Javaでいえばfinalで定数化して再代入を防ぐ。

#### 4.1.2 引数も不変にする

* 引数に対しても行う。

### 4.2 可変がもたらす意図せぬ影響

#### 4.2.1 ケース1 可変インスタンスの使い回し

* GUIで言えば「スタイル用クラスオブジェクトを引数として渡してコントロールのデザインを動的に変更する」といった場面の場合、control1, control2 はそれぞれ別の style1, style2 といった感じで渡すオブジェクトも新しく作る。そうするとstyle1が変更されてもstyle2は変更していないため副作用が小さく済む。

#### 4.2.2 ケース2 関数による可変インスタンスの操作

* オブジェクトが持つデータも注意が必要。マルチスレッドのような場面でスレッド1が想定しないメソッドの呼び出しでデータが破壊される可能性があるため。

#### 4.2.3 副作用のデメリット

* 想定したデータの変更以外の変更に注意せよ。

#### 4.2.4 関数の影響範囲を限定する

* 以下に従って設計すること。
  * データ、つまり状態を引数で受け取る。
  * 状態は変更しない。
  * 値は関数の戻り値として返す。

#### 4.2.5 不変にして予期せぬ動作を防ぐ

> 仕様変更時に意図せず副作用のある関数が作りこまれてしまい、予期しない動作を招いてしまう、ということがよくあります。(当書 p.50)

### 4.3 不変と可変の取り扱い方針

#### 4.3.1 デフォルトは不変に

* 通常は不変で行う。

#### 4.3.2 どんなときに可変にしてよいか

* 「大量のデータを高速に処理する場合」や「リソース制約の強い環境」、「画像処理」といった**パフォーマンスに影響が出る場合は可変**にしてよい。
* もしくはループ処理内といったスコープが小さい場合も可変を認める。

#### 4.3.3 正しく状態変更するメソッドを設計する

* データの管理は基本的にオブジェクトに行わせるべき。

#### 4.3.4 コード外とのやりとりは局所化する

* ファイルの読み書きやDB操作といった外部とやりとりする場合は注意が必要。

## 第5章 低凝集－バラバラになったモノたち－

* **凝集度**(ぎょうしゅうど)とは『モジュール内における、データとロジックの関係性の強さを表す指標』らしい。

### 5.1 staticメソッドの誤用

#### 5.1.1 staticメソッドはインスタンス変数を使えない

* staticメソッドからはメンバ変数を直接弄ることはできないため、基本的にはstaticメソッドは作らないようにすべき。

#### 5.1.2 インスタンス変数を使う構造につくり変える

* staticにせずにオブジェクト側に任せるようにすべき。

#### 5.1.3 インスタンスメソッドのフリしたstaticメソッドに注意

* 以下のコードのAddメンバ関数のような『メンバ変数を使わずに単に計算するだけの処理』もstaticが付いていないだけで似たようなもの。

```C++
class PaymentManager{
  private:
      int m_discountRate; // 割引率
  public:
      // ...


      // ↓ メンバ変数m_discountRateを使わずに単に引数で計算しているだけ
      int Add( int moneyAmount1, int moneyAmount2 ){
        return moneyAmount1 + moneyAmount2;
      }
}
```

#### 5.1.5 どういうときにstaticメソッドを使えばいいのか

* Factoryパターンや『**凝集度に影響のない場合**』ならstaticメソッドを使うことができる。

### 5.2 初期化ロジックの分散

* 下記のコードのような場合を考えてみる。このコードでもし仮にGiftPointコンストラクタに渡す引数が変更になったらどうなるだろうか。その場合はすべてのコードを修正しなくてはならない。

```C++
GiftPoint* standardMemberShipPoint = new GiftPoint( 3000 );
GiftPoint* premiumMemberShipPoint  = new GiftPoint( 10000 );
```

#### 5.2.1 privateコンストラクタ+ファクトリメソッドで目的別初期化

* 5.2 のコードで、コンストラクタをprivateにしてFactoryパターンによって生成する方向にする。

```C++
GiftPoint* standardMemberShipPoint = GiftPoint::CreateStandardMemberShip();
GiftPoint* premiumMemberShipPoint  = GiftPoint::CreatePremiumMemberShip();
```

#### 5.2.2 生成ロジックが増えすぎたらファクトリクラスを検討すること

* 5.2のコードでは『プレミアム会員』と『通常会員』の2種類だけだが、これがさらに多くなると『このクラスが何をしているか』がわかりにくくなるため、そういう場合はあえてFactory系のクラスとして切り出すべき。

### 5.3 共通クラス (Common・Uitl)

#### 5.3.1 さまざまなロジックが雑多に置かれがち

* Util系のクラスは注意が必要。いわゆる神クラスと呼ばれるような不作法なクラスになりがち。

#### 5.3.2 オブジェクト指向設計の基本に立ち返ろう

* 共通クラスを安易に作らないようにすべき。

#### 5.3.3 横断的関心事

* ログ出力やエラー検出といったよく必要とされる基盤的な処理のことを**横断的関心事**という。
* このような横断的関心事に関する処理ならstaticにしてもOK。

### 5.4 結果を返すために引数を使わないこと

* 出来る限りC++でいう『戻り値扱いの引数』は使わないようにすべき。戻り値扱いにしてしまうと、副作用が出てしまい、意図しない結果になりやすいため。

### 5.5 多すぎる引数

* よく、``new Chara( name, hp, mp, attackPower, ... )``と引数がやたら多い場合がある。そのケースについて考えてみる。

#### 5.5.1 プリミティブ型執着

* boolean, string, char, int ... といったプリミティブ型を乱用するのは避けること。可能であれば専用のクラス作るべき。(例: 金に関する引数 → Moneyクラス, Currencyクラス)

#### 5.5.2 意味のある単位ごとにクラス化する

* RPGの場合はMP(魔力)といったものはオブジェクト化してそのオブジェクトに管理を任せるべき。そのMagicPowerクラスのようなオブジェクトをCharaクラスが保持して管理するといった方式にすべき。

### 5.6 メソッドチェイン

* メソッドチェーンで実装するとデータの値を知っていなければいけないのであまりよろしくない。

#### 5.6.1 尋ねるな、命じろ

* ソフトウェア設計では**尋ねるな、命じろ**(Tell, Don't Ask.)という有名な格言がある。簡単に言えば『オブジェクトに管理させるべき』という考え方だ。

## 第6章 条件分岐－迷宮化した分岐処理を解きほぐす技法－

### 6.1 条件分岐のネストによる可読性低下

* 条件分岐のネストが深ければ深いほど読みづらくなる。

#### 6.1.1 早期returnでネスト解消

* 「HPがゼロ(以下)の場合、何もせずにreturnする」といった処理を先頭に付ければネストが深くならずに済む。

#### 6.1.2 見通しを悪くするelse句も早期returnで解消

* else句も早期returnの対象にできる。

### 6.2 switch文の重複

* 以下のようなケースを考えたとき、getNameメソッドやcostMagicPointメソッドといったメソッド内で何度もswitch文で分岐させる場合を想定。

```
[魔法]
* 名前: 魔法の名前。表示に用いる。
* 消費魔法力: 魔法使用時に消費する魔法力。
* 攻撃力: 魔法の攻撃力。それぞれ計算式が異なる。
```

#### 6.2.1 即座にswitch文を書いてしまう

* そのまま書くとgetNameメソッドやcostMagicPointメソッドといったメソッド内で何度もswitch文で分岐させることになる。(良くない)

#### 6.2.2 同じ条件式のswitch文が複数書かれていく

* 「魔法の『名前』用」、「魔法の『消費魔法力』用」、「魔法の『攻撃力』用」といったようにそれぞれswitch文を用意すると更に可読性が下がる。

#### 6.2.3 仕様変更時の修正漏れ (case文追加漏れ)

* switch文に新しいcase文を追加した場合は別のところでも修正が発生するが、修正し忘れることも起こり得る。

#### 6.2.4 爆発的に増殖するswitch文の重複

* サンプルでいえば「魔法」の種類が増えれば増えるほど修正時の対応が難しくなっていく。

#### 6.2.5 条件分岐を一箇所にまとめる

* コンストラクタ内やinitメソッド内のような初期化系メソッドで、一括で初期設定する。

#### 6.2.6 よりスマートにswitch文重複を解消するinterface

* OOP的発想でコーディングするとなおスマートに。

#### 6.2.7 interfaceをswitch文重複に応用 (ストラテジパターン)

* Map(言語によってはDictionaryとなっていたりする)も使って ``Map<MagicType, Magic> magics``とすれば、``magics.get( MagicType.Fire )``のようにオブジェクト自身に命令することができる。
* また更に、Magicインターフェースが返す戻り値や引数もオブジェクト化してプリミティブ型を出来る限り避ける。

### 6.3 条件分岐の重複とネスト

#### 6.3.1 ポリシーパターンで条件を集約する

* 『シルバー会員かどうかを判定したい』といった場合、ポリシーパターンと呼ばれるパターンを適用すれば奇麗に書ける。
* ``ExcelentCustomerRule``インターフェースを用意して、『ゴールド会員の購入金額ルール』や『購入頻度のルール』『返品率のルール』といったクラスをそれぞれ定義する。

// TODO: 要学習

### 6.4 型チェックで分岐しないこと

* せっかくinterfaceを実装してオブジェクトに任せても、``instanceof``といったオブジェクトの型を調べてから使う方法だとそのメリットを台無しにしてしまう。

### 6.5 interfaceの使いこなしが中級者への第一歩

* interfaceを使いこなせるようになればOk。

### 6.6 フラグ引数

* boolean系の引数で『魔法で攻撃する』か『物理攻撃で攻撃する』かといった分岐がされているような場合も注意が必要。

#### 6.6.1 メソッドを分離する

* そういうboolean系引数で分岐させるぐらいならメソッドを分離すべき。

#### 6.6.2 切り替え機構をストラテジパターンで実現する

* Strategyパターンを適用して実装。

