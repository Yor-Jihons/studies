# 「テスト駆動開発」の要約

## 第1章 仮実装

Step1. あえてコンパイルの通らないコードでアウトラインを書く。

```C++
#include<iostream>
#include<cassert>

namespace std;

int main( void ){
    Test1::Class1 obj; // <- そもそもこのスコープにTest1::Class1クラスが無いのでコンパイルエラー。
    bool r = obj.Run(); // <- 上と同じ理由でここもコンパイルエラー。
    assert( r );

    int n = CONSTANT1 + 8; // <- #defineで定義した定数を使おうとしているがコンパイルエラー。

    // ...
}
```

Step2. そしてこのコードがコンパイル通るようにコードを書いていく。
つまり、``Test1::Class1``クラスや``Test1::Class1::Run``メンバ関数を実装し、``CONSTANT1``定数を定義する。
まずは``Test1::Class1``のコンストラクタが通るようにして、その次に``Test1::Class1::Run``メンバ関数を通す。
…とやっていく。フィールド(メンバ変数)が未定義の場合はそれらも追加していく。

次の段階で、``bool r = obj.Run();``のassert関数(マクロ)のステップで失敗する。
さらにそのステップも成功するようにコードを修正する。

Step3. 重複の除去を行う。

> TDDで大事なのは細かいステップを踏むことではなく、細かいステップを**踏み続けられる**ようにすること (p10)


```
[FLOW]
1. 小さいテストを1つ書く。
2. すべてのテストを実行し、1つ失敗することを確認する。
3. 小さい変更を行う。
4. 再びテストを実行し、すべて成功することを確認する。
5. リファクタリングを行い、重複を除去する。
```

## 第二章 明白な実装 Degenerate Objects

基本的には以下のようなサイクルになる。

```
1. テストを書く。大筋でもいいから頭の中で想像した操作がどんなコードとして現れるかを考える。
2. 動かす。テストがすべて通り、バーがグリーンになるように素早く実装する。このステップでは違反もスルーする。
3. 正しくする。
```

## 第三章 三角測量 Equality for All

Value Objectパターンと呼ばれるパターンを適用して、**コンストラクタで設定した値から変更されないようにする**ことも大事。

また、**三角測量**と呼ばれる実装戦略で行うべきである。恐らく抽象化のことだろう。
