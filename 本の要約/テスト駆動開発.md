# 「テスト駆動開発」の要約

## 第Ⅰ部 多国通貨

### 第1章 仮実装

Step1. あえてコンパイルの通らないコードでアウトラインを書く。

```C++
#include<iostream>
#include<cassert>

namespace std;

int main( void ){
    Test1::Class1 obj; // <- そもそもこのスコープにTest1::Class1クラスが無いのでコンパイルエラー。
    bool r = obj.Run(); // <- 上と同じ理由でここもコンパイルエラー。
    assert( r );

    int n = CONSTANT1 + 8; // <- #defineで定義した定数を使おうとしているがコンパイルエラー。

    // ...
}
```

Step2. そしてこのコードがコンパイル通るようにコードを書いていく。
つまり、``Test1::Class1``クラスや``Test1::Class1::Run``メンバ関数を実装し、``CONSTANT1``定数を定義する。
まずは``Test1::Class1``のコンストラクタが通るようにして、その次に``Test1::Class1::Run``メンバ関数を通す。
…とやっていく。フィールド(メンバ変数)が未定義の場合はそれらも追加していく。

次の段階で、``bool r = obj.Run();``のassert関数(マクロ)のステップで失敗する。
さらにそのステップも成功するようにコードを修正する。

Step3. 重複の除去を行う。

> TDDで大事なのは細かいステップを踏むことではなく、細かいステップを**踏み続けられる**ようにすること (p10)


```
[FLOW]
1. 小さいテストを1つ書く。
2. すべてのテストを実行し、1つ失敗することを確認する。
3. 小さい変更を行う。
4. 再びテストを実行し、すべて成功することを確認する。
5. リファクタリングを行い、重複を除去する。
```

### 第2章 明白な実装 Degenerate Objects

基本的には以下のようなサイクルになる。

```
1. テストを書く。大筋でもいいから頭の中で想像した操作がどんなコードとして現れるかを考える。
2. 動かす。テストがすべて通り、バーがグリーンになるように素早く実装する。このステップでは違反もスルーする。
3. 正しくする。
```

### 第3章 三角測量 Equality for All

Value Objectパターンと呼ばれるパターンを適用して、**コンストラクタで設定した値から変更されないようにする**ことも大事。

また、**三角測量**と呼ばれる実装戦略で行うべきである。恐らく抽象化のことだろう。

### 第4章 意図を語るテスト Privacy

```C++
// コード1

Class1* obj1 = new Class1(10);
Class1* obj2 = obj1.times(2);
assert( obj1.amount == 20 );
```

```C++
// コード2

Class1* obj1 = new Class1(10);
Class1* obj2 = obj1.times(2);
assert( obj1.Equals( new Class1(20) ) );
```

コード1のような直接値を出すようなコードよりも、コード2のようにオブジェクト化して**意図を明確にする**べきである。
こうすることでClass1が持つメンバ変数amountをprivateにできる。
これにより、更にコード3のようにobj2すら生成しなくて済む。

```C++
// コード2

Class1* obj1 = new Class1(10);
//obj1.times(2); // <- 不要なコード
assert( obj1.times(2).Equals( new Class1(20) ) );
```

この時点では「もしこのロジック自体が間違っている場合はすべて間違っている」というリスクがあるが、**あえてこのリスクを受け入れることも大事***である。

### 第5章 原則をあえて破るとき Franc-ly Speaking

通常「コピペをするな、継承等を使え」と言われるがここでは**あえてその原則を破る**。とりあえず動いてグリーンにするコードにする。

### 第6章 テスト不足に気づいたら Equality for All, Redux

テスト不足を恐れなくていい。気づいた時点でテストを追加すればいいだけだから。

### 第7章 疑念をテストに翻訳する Apples and Oranges

DollarクラスとFranc(フラン)クラスの比較といった処理のようにうまくいくかどうか、どのように実装すべきか悩むようなものもテスト対象に組み込む。
つまり、**頭の中にある悩みをテストにも反映させる**。

### 第8章 実装を隠す Makin' Objects

FactoryMethodパターンやポリモーフィズムを利用して実装を隠蔽する。

### 第9章 歩幅の調整 Times We're Livin' In

継承・実装を利用したポリモーフィズムを使う?

### 第10章 テストに聞いてみる Interesting Times

* 手戻りを恐れず、必要があれば手戻りも行う。当書ではtimesメソッドの処理を``return Money.dollar( this.amount * multiplier );``のようにしていたがあえて戻して``return new Dollar( this.amount * multiplier, "USD" );``のように修正した。さらに"USD"のような値はコンストラクタで与えることできるので、``return new Dollar( this.amount * multiplier, this.currency );``のようにオブジェクトのフィールドを渡すように書き換えていた。

* また、テスト用のToStringメソッドのようなものはテスト対象に含めなくとも良いことがある。
(バグが混入していてもリスクが少ないため。)

* さらに本章では

```C++
Money* times( int multiplier ){
    return new Money( this->amount * multiplier, this->currency );
}
```

のようにしてスーパークラス側のコンストラクタで生成して返している。

* 当書ではサブクラスたちのtimesメソッドの実装の差異を無くすように書き換えている。

### 第11章 不要になったら消す The Root of All Evil

不要なクラスやメソッドを消す勇気も持つ。

### 第12章 設計とメタファー Addition, Finally

複雑な処理(ドル + 円のような)はそのメタファーを考えてテストを作る(?)

### 第13章 実装を導くテスト Make It

複雑な処理はインターフェースを先に作る等をして外堀から埋めていく。

### 第14章 学習用テストと回帰テスト Change

* 2フランを1ドルに変換するといった処理の場合、「amount÷2」のようなとりあえずGreenになるような処理にしておく。
その後で実装する。
* 当書では「為替レート」についてはBankクラスが担当するようにしていた。
* Bankクラスが担当するフラン⇔ドルのようなレート変換はPairで保持するとやりやすくなる。

### 第15章 テスト任せとコンパイラ任せ Mixed Currencies

* 抽象度の低い部分から開始し、最終的に抽象化していく。(その逆もできるが)
* コンパイルエラーが出たならそのメッセージを読んで対処する。

### 第16章 将来の読み手を考えたテスト Abstraction, Finally

* テストも他人が読んでわかるように書くべき。

### 第17章 他国通貨の全体ふりかえり Money Retrospective

* (1章から16章までのまとめ)

## 第Ⅱ部 xUnit

### 第18章 xUnitへ向かう小さな一歩 First Steps to xUnit

* この章ではxUnit方式(?)で自動テストを行うための初期設定についてPythonで説明している。
今までの章と同じようにひとつずつ組み立てていく。

### 第19章 前準備 Set the Table

* テストの流れは「**準備**(Arrange)」「**実行**(Act)」「**アサート**(Assert)」の三つ(Bill Wake氏は**3A**と呼んでいるらしい)で構成される。
* テストAの直後のテストBはうまく行くがテストBの直後のテストAは失敗するケースは作ってはならない。つまり「**テスト間で依存関係を作ってはならない**」。そのため、テストクラス側にSetupメソッドを追加するなりして「テスト内でテスト直前にSetupメソッドを呼んで初期化する」といった処理をするべきである。

### 第20章 後片付け Cleaning Up After

* Windows APIでいうリソース(特にHDC等)のように破棄が必要な場合もtearDownメソッド(afterメソッドでもいい)で破棄できるようにしておく。(そのためのテストも行う)

### 第21章 数え上げ Counting

* "3 run, 0 failed" のようなテストを数え上げる処理も今までと同様にテスト駆動で作り上げる。

### 第22章 失敗の扱い Dealing with Failure

* テスト中の例外処理もテスト対象に含める。

### 第23章 スイートにまとめる How Suite It Is

* 当書ではxUnitのTestSuiteと呼ばれる機能を用いてテストする方向性にしている。

### 第24章 xUnitの全体ふりかえり xUnit Retrospective

* xUnit等のテストシステムを使うと開発が楽になる。


