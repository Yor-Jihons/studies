# テスト駆動開発の要約まとめ

## 基本

* テストは他人が読んでわかるように書くべき。
* テスト駆動開発(TDD)は**テストから書き始めて、テストが通るように組み立てていく**。
* 最初からすべてのテストを割り出す必要はなく、思いついた時点で追加していけばいい。
* テスト対象やどのようなテスト値を扱うかといったものをToDoリストに記録して、実装後に消していくというスタイルでやる。
* また、TDDは必ず**レッド・グリーン・リファクタリング**の流れで行う。これ以外の流れでやると失敗しやすくなる。
* レッドからグリーンまでは**あえてリスク(SOLIDの原則等に違反することを含む)を受け入れることも大事***である。
* リファクタリングするときはステップを細かいステップに分割するように心がける。リファクタリング時はバグが入りやすいため。
* 「条件分岐、ループ、操作、ポリモーフィズム」が主なリファクタリング対象。ただし自分が書いたコードが対象。
* 手戻りが発生しても**恐れずに戻って**対応する。
* テストは**平均故障間隔**(MTBF: Mean TIme Between Failures)を思い浮かべながら回数を想定すると楽…らしい。
* 絶対的な自信があるならテストを省くことができるが、そうでないなら省くべきではない。
* テストは読み手にシナリオが伝わりづらい場合は省くべきではない。
* 単体テストよりも大きいテスト(結合テストや総合テスト等)も検討してみる。
* すでに開発が途中段階にあるプロジェクトにTDDに切り替えるのは基本的にはお勧めしない…らしい。
* テストはデザインパターン等のパターンとも関係性がある。
* (テストした際の欠陥の減少は科学的根拠に乏しいが)開発者に心的ストレスがかかりにくくなり、ラフな状態で開発に挑める。
* 直接値を出すようなコードよりも、コード2のようにオブジェクト化して**意図を明確にする**べき。
* ToStringメソッドのようにテストせずとも(バグがあっても)痛手にならないものはテストを行わなくてもOK。
* 不要なメソッドやクラスは消す勇気を持つ。
* 複雑な処理はインターフェースから実装していく。すでに実装がわかっている場合は実装から記述してOK。

* xUnit等のテストを自動化するシステムも利用していく。
* Windows APIでいうリソース(特にHDC等)のように破棄が必要な場合もtearDownメソッド(afterメソッドでもいい)で破棄できるようにしておく。(そのためのテストも行う)
* "3 run, 0 failed" のようなテストを数え上げる処理も今までと同様にテスト駆動で作り上げる。
* テスト中の例外処理もテスト対象に含める。

* テストした場合はしない場合と比較してバグの早期発見が簡単になる。
* 独立したテストを行うべき。
* 毎回、細かい精度でのToDoリストを作るべき。そうすることで必要なものがその都度取り出せるからだ。
* テストファーストで書くべき。つまりテストケース→テスト対象の順番で記述していく。
* テストするときはとりあえず「**正しい結果とは何か**」や「**それをどう検証するか**」の2つで考える。そこから必要なものを割り出していく。
* テストデータは不必要なデータ(同じデータ等)は定義しないこと、また出来る限り「本番に近いデータ」を用いるべき。

## 流れ

* TDDの流れはレッド・グリーン・リファクタリングで行う。

* 基本的には以下のようなサイクルになる。

```
1. テストを書く。大筋でもいいから頭の中で想像した操作がどんなコードとして現れるかを考える。
2. 動かす。テストがすべて通り、バーがグリーンになるように素早く実装する。このステップでは違反もスルーする。
3. 正しくする。
```

### Step1. あえて失敗するテストを記述する

* たとえ呼び出されるクラスを実装せずに「こういうデータを渡すとこういうデータが返ってきてほしい」という意図でテストを記述する。
* テストを書く。大筋でもいいから頭の中で想像した操作がどんなコードとして現れるかを考える。
* テスト処理の流れは「**準備**(Arrange)」「**実行**(Act)」「**アサート**(Assert)」の三つ(Bill Wake氏は**3A**と呼んでいるらしい)で構成される。
* ただし、 テストAの直後のテストBはうまく行くがテストBの直後のテストAは失敗するケースは作ってはならない。つまり「**テスト間で依存関係を作ってはならない**」。そのため、テストクラス側にSetupメソッドを追加するなりして「テスト内でテスト直前にSetupメソッドを呼んで初期化する」といった処理をするべきである。

```C#
public UnitTest1
{
    [Fact]
    public void Test1()
    {
        bool ret = Class1.Run( 100 ); // この時点ではまだClass1.Runメソッドが定義されていないためコンパイルエラーになる。
        Assert.True( ret );
    }
}
```

### Step2. すぐさま仮の値を返すような一時的な処理を記述してテストを通す (グリーン)

* このステップではSOLID原則といった原則等に違反しても気にせず行う。(Step4が済めば結果的に原則を守ることになるため。)
* コンパイルエラーのメッセージ等を利用してコーディングしていく。

```C#
public static class Class1
{
    public static bool Run( int n )
    {
        return true; // 一応テストが通るように仮の値を返しておく。
    }
}

// ...

public UnitTest1
{
    [Fact]
    public void Test1()
    {
        bool ret = Class1.Run( 100 );
        Assert.True( ret ); // // このステップでは一応通るが、一時的なダミーデータとなっている。
    }
}
```

### Step3. すぐに実際の処理を記述してテストを通す

* コンパイルエラーのメッセージ等を利用してコーディングしていく。

```C#
public static class Class1
{
    public static bool Run( int n )
    {
        // 実際の処理を記述する。
        if( n == 100 ) return true;
    return false;
    }
}

// ...

public UnitTest1
{
    [Fact]
    public void Test1()
    {
        bool ret = Class1.Run( 100 );
        Assert.True( ret ); // // このステップで一応実装は完了している。
    }
}
```

### Step4. リファクタリングを行う (リファクタリング)

* このステップでは処理をシンプルにしたり、重複した処理を関数(or クラスやメソッド)として切り出す。


```C#
public static class Class1
{
    public static bool Run( int n )
    {
        // たとえば処理をシンプルにしたりする。
        return (n == 100 ? true : false);
    }
}

// ...

public UnitTest1
{
    [Fact]
    public void Test1()
    {
        bool ret = Class1.Run( 100 );
        Assert.True( ret ); // リファクタリングがちゃんと出来ていればグリーンの状態。
    }
}
```

この流れを小さく迅速に行っていく。

### レッドバーのパターン

* 脱線するような内容はToDoリストに記述してすぐさま処理に戻るべき。
* 不具合が報告された場合はそのテストをしてGreenになればOK。
* 休憩は必要。
* 手詰まりが発生したら破棄してやり直すのもあり。


## その他の作法

### 三角測量

* 「引数(1,2)を渡せば3が返り、引数(3,5)を渡せば8が返る」といった規則性を割り出すためのテストも追加する。
* さらにその規則性から抽象化した処理を実装する。





### Mock Object (擬装オブジェクト)パターン

* 「データベースから取ってきたデータ」を処理するメソッド等をテストするときはmock objectと呼ばれる「ダミーのデータを返すオブジェクト」を作成してそれをDBと見なすといったパターン。
* それでも重いリソースは引数として渡せばいい。

### Self Shunt (自己接続)パターン

* (テストクラス側でカウントして、「ちゃんとオブジェクトAとBがやり取りできているか」見る?)

// TODO: 要学習

### Log String (記録用文字列)パターン

* 「正しい順序でメソッドが呼ばれているか」をテストするには「testMethod tearDown」といった文字列を一つのテストで一つの文字列を出力しながら行うのが良いらしい。たとえばテストAで「testMethod」を出力し、テストBで「tearDown」と出力するとか。
* Observerパターンを実装しているオブジェクトをテストするときに有用。

### Crash Test Dammy (衝突ダミー人形)パターン

* 例外処理もテストしたい場合はあえて例外を投げてみる。(イメージ的にはMock Objectパターンの例外処理版。)

### 失敗させたままのテスト

* (一人でコーディングしている場合)席を立つときのような場合はあえてテストが失敗するように仕向ける。こうすればどこまでやったかわかるため。

### きれいなチェックイン

* (チーム開発の場合)席を立つときといった場合はその逆にテストがGreenになるようにする。

### 明白な実装

* すでにわかっている実装はそのまま書くべき。

> 「きれいなコード」と「動くコード」を一度に満たすのは、えてして難しいものだ。少しでも難しいと思ったら後戻りして、まず「動く」を仕留め、その後ゆっくりと「きれいな」を手がけよう。(p221)

### 一から多へ

* コレクションを扱う操作を実装する場合は単数の場合を実装し、それからコレクションでも動くようにするべき。

例:

```C#
Assert.Equal( 5, Calculator.Sum( 5 ) ); // 0 に 5 を足した値を返すメソッドを定義。
```
↓
```C#
Assert.Equal( 5, Calculator.Sum( 5, new int[] { 5 } ) ); // コレクションで渡す。
```
↓
```C#
Assert.Equal( 5, Calculator.Sum( new int[] { 5 } ) ); // コレクションで渡して、単数の値は不要なので削除。
```
- **Commandパターン**: 処理の実行をただのメッセージではなく、オブジェクトで表現する。
- **Value Objectパターン**: 一度作られたら絶対に値が変わらないオブジェクトを作り、別名参照を防ぐ。
- **Null Objectパターン**: 特殊な状況をオブジェクトで表現する。
- **Template Methodパターン**: 処理の順序を抽象メソッドの並びで表現し、個別の処理は継承によって実現する。
- **Pluggable Objectパターン**: 2種類以上の実装を持つオブジェクトを持つことでバリエーションを表現する。
- **Pluggable Selectorパターン**: インスタンスごとに異なるメソッドを動的に呼び出すことで、余計なサブクラスを作らずに済ませる。
- **Factory Methodパターン**: コンストラクタではなく、メソッドを良い美出してオブジェクトを作成する。
- **Imposterパターン**: 既存プロトコルの新たな実装を作成して、バリエーションを生み出す。
- **Compositeパターン**: オブジェクトたちの振舞いの組み合わせを1つのオブジェクトとして表現する。
- **Collection Parameterパターン**: さまざまなオブジェクトから処理結果を集めるためのオブジェクトを引数に渡していく。

### Commandパターン

// TODO: 要学習

### Value Objectパターン

* C++でいえば``std::string::substr``メンバ関数のように新しいオブジェクトを生成して値が不変になるように設計したオブジェクト。

### Null Objectパターン

* メインのテスト対象以外の部分(引数として与えるオブジェクトやDBから引っ張ってきたデータ等)は空のオブジェクト(またはダミーデータのオブジェクト)を新たに用意する。

### Template Methodパターン

* GoFのデザインパターンのもの。

### Pluggable Objectパターン

* Pluggable = プラグイン可能な。
* たとえば「マウスの選択状態によって処理を変える」場合は通常の実装だとどうしてもif文やswitch文で分岐させることになるが、テストしづらいのでオブジェクト化して管理を任せる。MouseSelectionModeインターフェースを作成し、これを実装して「選択時」と「非選択時」のそれぞれのオブジェクトで判断させるとか。

```C#
public class MyWindow
{
    public MyWindow()
    {
        // ...
    }

    private MouseSelectionMode Mode{ get; set; }
    private Figure Selected{ get; set; }

    public void MyWindow_MouseDown( /* ... */ )
    {
        // ...

        // こういう風にオブジェクト自身で判断させる
        if( selected != null )
        {
            mode = new MouseSingleSelection( selected ); // マウスの選択モードがシングルの場合
        }
        else
        {
            mode = new MouseMultipleSelection(); // マウスの選択モードがマルチの場合
        }
    }

    public void MyWindow_MouseMove( /* ... */ )
    {
        mode.MouseMove();
    }

    public void MyWindow_MouseUp( /* ... */ )
    {
        mode.MouseUp();
    }
}
```

### Pluggable Selectorパターン

// TODO: 要学習

### Factory Methodパターン

* GoFのデザインパターンのもの。

### Imposterパターン

// TODO: 要学習

### Compositeパターン

* GoFのデザインパターンを応用したもの。

### Collecting Parameterパターン

* コレクション内のオブジェクトをファイルに記録するといったときに、コレクションされているオブジェクトにC#でいう``System.Text.StringBuilder``クラスのオブジェクトを渡して記録してもらうパターン。

```C#
public class Class1
{
    public Class1()
    {
        // ...
    }

    // ...

    public void ToString( System.Text.StringBuilder builder )
    {
        builder.Append( this.Name );
        builder.Append( "," );
        builder.Append( this.Number );
    }
}
```

### Singletonパターン

* やるな!


### グリーンバーのパターン

* 戻り値をべた書きしたりして仮実装し、すぐさま本実装(本来の戻り値)に編集するべき。こうすることで「心的負担」が少なく、そのテスト対象だけにフォーカスできる。
* 不要なコードであっても恐れず書いていき、奇麗にしていくべき。

### xUnitのパターン

* アサーションメッセージは"Assertion failed: Should be true"のように「どうなれば成功だったのか」をメッセージにするとわかりやすい。
* 複数のテストから扱いたいオブジェクトを生成するにはsetUpメソッドのようなメソッド内で生成してフィールドとして保持する。ただし、setUpメソッドの内容を覚えておく必要があるため、使いどころを考える必要あり。(ちなみにこの共通した部分をフィクスチャーというらしい。)
* 外部リソースを解放するにはtearDownメソッドのようなものを実装する。
* テストメソッドの中は**平易で読みやすく書くべき**である。
* テストメソッドの長さは3行を目指すべき。
* 例外をテストする場合は以下のように例外を握りつぶして、例外が投げられた後の行に失敗系のアサーションを入れる。ただし、**期待される例外だけキャッチするべき**。

```C#
try
{
    var obj1 = new Class1();
    obj1.MethodThrowingException(); // このメソッドが例外を飛ばす可能性あり。
    fail(); // このメソッドで「失敗した」系のメッセージを表示
}catch( SomthingException e )
{
    // あえて握りつぶす
}
```

## リファクタリング

* リファクタリングで気にかけなければならないのは**対象はすでに通っているテストである**ということ。
* たとえば「2つのループ構造がよく似ている。関数として切り出そう。」といった具合の処理もリファクタリングである。

### 変更の分離

* 簡単に言えば「(共通部分を)関数として切り出す処理」といったところ。(当書では「インライン化」と言っているようだが。)

### データ構造の変更

* クラスが持つフィールド(メンバ変数)のデータ構造を配列構造からリスト構造に変更するといった場合は以下のようにすると楽。

```
[内側から外側に向かってリファクタリングする場合]

1. 新構造のためのフィールド(メンバ変数)を定義する
2. 旧構造でデータが設定されている部分をその変数に置き換える
3. 旧構造のデータを使っている部分をその変数に置き換える
4. 旧構造のコードを消す
5. 外部インターフェースに新構造を反映させる
```

```
[API側から修正する場合(インターフェースから変更していく)]

1. 新構造のパラメータを追加する
2. 新構造のパラメータを内部で旧構造に変換する
3. 旧構造のパラメータを削除する
4. 旧構造を使っている部分を新構造に置き換えていく
5. 旧構造のコードを削除する
```

### メソッドの抽出

* メソッドの抽出(Extract Method)することで可読性を上げる。

```
[方法]

1. メソッドの中から、新しいメソッドとして切り出す意味のある部分を探す。ループの中身やループ全体、条件分岐の各分岐などがよくある抽出対象だ
2. 抽出する範囲の外で一時変数への代入が行われていないことを確認する
3. 旧メソッドから該当範囲のコードをコピーし、コンパイルする
4. 旧メソッドの一時変数やパラメータの中で新メソッドから使うものを、新メソッドのパラメータに追加する
5. 旧メソッドの中から新メソッドを呼び出す
```

#### メソッドのインライン化

// TODO: 要学習

```
[方法]

1. 対象メソッドをコピーする
2. メソッド呼び出し部分にそのメソッド本文をペーストする
3. 仮引数を実引数に置き換える。たとえばもしreader.getNext()の結果を渡しているのなら、副作用を生む式であることに注意してローカル変数に代入する
```

### インターフェースの抽出

* ポリモーフィズムを表現できるようにする。

### メソッドの移動


たとえばShapeクラスで以下のようなコードがあるとする。

```Java
private Rectangle bounds;

// ...
int width = bounds.right() - bounds.left();
int height = bounds.bottom() - bounds.top();
int area = witdth * height;
// ...
```

このクラスが持つboundsが処理するメッセージが多すぎな上、「面積を計算する」のはShapeクラスではなくRectangleなはずなのでRectangleクラスにareaメソッドを作ってそのメソッドを呼び出すようにする。

```
[利点]

* 対象コードの意味を深く捉えなくとも、メソッド移動の必要性があることは容易にわかること。1のオブジェクトに対して2つ以上のメッセージ呼び出しが行われているのは、移動のサイン
* 素早く安全に行う手順が存在すること
* 芽を見張るような結果になることが多いこと
```

```
[方法]

1. メソッドをコピーする
2. 移動先クラスにペーストし、名前を整え、コンパイルする
3. 移動元のオブジェクトがメソッド内で参照されている場合、移動先オブジェクトをメソッドのパラメータに加える。移動元オブジェクトの変数がメソッド内で参照されている場合もそれをパラメータとして加える。メソッド内でフィールドへ代入が行われている場合はリファクタリングを諦める
4. 移動元クラスのメソッドの中身を新しいメソッドの呼び出しに書き換える
```

### メソッドオブジェクト

* 多分、メソッドの引数が多すぎる場合にやる「オブジェクトのくくり出し」のことを言っていると思われる。Windows APIで構造体オブジェクトを渡すような感覚。

```
[方法]

1. オブジェクトを作り、メソッドと同じパラメータを保持させる
2. ローカル変数はそのオブジェクトのインスタンス変数として表現する
3. 単一のメソッド run を定義し、その中身は元のメソッドと同一にする
4. 元のメソッドの中でオブジェクトをインスタンス化し、runメソッドを呼び出す
```

### パラメータの追加

```
[方法]

1. メソッドがインターフェースに定義されている場合は、インターフェースの方を先にパラメータを追加する
2. パラメータを追加する
3. コンパイルエラーを活用して呼び出し側コードの修正点を調べる
```

### メソッドからコンストラクタへのパラメータの移動

```
[方法]

1. コンストラクタへパラメータを追加する
2. そのパラメータと同名のインスタンス変数を定義する
3. コンストラクタ内でインスタンス変数への代入を行う
4. パラメータ parameter の参照を1つずつthis.parameterへ書き換えていく
5. パラメータへの参照が無くなったら、メソッドからパラメータを削除し、呼び出し側からも削除する
6. もう付ける必要のなくなった「this.」を消していく
7. インスタンス変数をふさわしい名前に変更する
```

## 臭うコード

* 臭うコード
  * **前準備に要するコードが長い**: アサーションを行うテスト対象オブジェクトの準備に100行のコードが必要なのであれば、何かおかしい。その場合は分割しろ。
  * **前準備コードの重複**: 共通の前準備コードを配置する場所がすぐに見つからない場合は、互いに密に関連しあう帯ジェクトが多すぎることを示唆している。
  * **テスト実行時間が長い**: TDDにおいて、テスト実行に時間が係すぐいると実行の頻度が低くなる。この場合は設計からやりなおすべき。目安は10分。
  * **脆いテスト**: 思わぬタイミングで失敗するテストは、アプリケーションのどこかが意外な形で他の部分に影響している可能性を示唆している。この場合は2つの部分の関係性を断つか、設計しなおすか。
